WEBVTT

1
00:00:01.280 --> 00:00:05.081
以下内容在CC协议下发布

2
00:00:05.081 --> 00:00:11.266
你的支持就是MIT OCW不断
提供高质量免费教学资源的动力

3
00:00:11.271 --> 00:00:12.580
如有意赞助MIT OCW

4
00:00:12.580 --> 00:00:16.070
或获取更多MIT成百上千的公开课资源

5
00:00:16.081 --> 00:00:21.211
请访问ocw.mit.edu

6
00:00:21.998 --> 00:00:24.020
JULIAN SHUN: 大家下午好

7
00:00:24.020 --> 00:00:28.219
欢迎来听6.172的第三讲

8
00:00:28.225 --> 00:00:31.128
今天我们学习位运算魔法

9
00:00:31.128 --> 00:00:33.380
今天的课会很有意思

10
00:00:36.034 --> 00:00:40.981
首先, 复习一下"字"的二进制表示

11
00:00:40.986 --> 00:00:45.132
一个w位的字可以如下表示

12
00:00:45.132 --> 00:00:52.229
我们从最右给每一位标号, 记为x_0...x_{w-1}

13
00:00:52.951 --> 00:00:59.499
而这个二进制表示所存储的无符号整数可以用以下公式计算

14
00:00:59.499 --> 00:01:08.510
本质上这是一堆二次幂的和, 对每一位和各自二次幂的乘积求和

15
00:01:08.516 --> 00:01:15.350
如果第k位是1, 你就乘上2^k
如果是0, 只要加上0就好了

16
00:01:15.350 --> 00:01:18.791
比如, 这里这个8位的二进制

17
00:01:19.508 --> 00:01:28.425
应用公式的话, 首先得到2, 因为第1位是1

18
00:01:28.425 --> 00:01:31.637
用2^1乘以1得到2

19
00:01:31.924 --> 00:01:38.229
而第2位处也有1, 所以用2^2乘以1得到4

20
00:01:38.940 --> 00:01:48.951
然后是16和128, 把这些二次幂加起来, 就是那个无符号整数

21
00:01:49.289 --> 00:01:54.480
0b这个前缀表示这是一个二进制常数

22
00:01:54.480 --> 00:01:58.710
也就是说我们要把这个数解释成一个二进制值

23
00:02:01.173 --> 00:02:09.204
也存在有符号整数, 可以用来表示负数, 这是补码(two's complement)表示

24
00:02:09.209 --> 00:02:14.032
这个公式可以补码表示的字所存储的值

25
00:02:14.037 --> 00:02:21.219
从第0位一直到w-2位, 都和无符号整数一样

26
00:02:21.219 --> 00:02:31.491
但对于最左, 或者第w-1位, 你要减去那一位和2^的乘积

27
00:02:31.502 --> 00:02:40.061
依然是这串二进制, 2 + 4 + 16还和上面一样

28
00:02:40.073 --> 00:02:47.038
但是对于最左的1, 我们减去2^7=128

29
00:02:47.056 --> 00:02:53.211
得到一个有符号整数, -106

30
00:02:53.768 --> 00:02:57.978
听得懂吗?对这个表示有疑惑吗?

31
00:03:01.205 --> 00:03:12.126
最左的这一位被称为符号位, 因为它决定你是否需要减去一个值

32
00:03:12.137 --> 00:03:20.110
如果符号位是0, 你什么都不用减
如果符号位是1, 你需要减去一个大整数

33
00:03:20.110 --> 00:03:25.180
所以补码表示, 一串二进制0就等于是0

34
00:03:25.180 --> 00:03:30.584
应用上面的公式, 因为每一位都是0, 所以结果就是0

35
00:03:31.295 --> 00:03:33.624
如果所有位都是1, 那么结果是多少?

36
00:03:36.760 --> 00:03:37.260
请答?

37
00:03:37.260 --> 00:03:38.580
听众: -1.

38
00:03:38.580 --> 00:03:40.308
JULIAN SHUN: -1, 对吧?

39
00:03:40.761 --> 00:03:47.058
为什么是-1呢, 你可以直接用公式验证

40
00:03:47.064 --> 00:03:52.959
我们要加一堆二次幂, 因为x所有位都是1

41
00:03:53.389 --> 00:03:58.004
我们从k=0到k=w-2对2^k求和

42
00:03:58.009 --> 00:04:03.534
这是个等比数列, 结果是2^-1

43
00:04:03.700 --> 00:04:08.028
对于符号位, 我们也要减去2^

44
00:04:08.034 --> 00:04:13.014
所以2^这一项消去了, 只留下一个-1

45
00:04:13.507 --> 00:04:22.799
这是补码表示的一个重要性质, 全1等于-1

46
00:04:24.342 --> 00:04:30.210
从这个性质可以推出此恒等式, x + x的反码(one's complement)

47
00:04:30.217 --> 00:04:35.727
反码就是把x的所有位反转, 然后x+~x=-1

48
00:04:36.255 --> 00:04:43.163
这是因为如果你加上一个所有位反转的数, 那所有位都变成1

49
00:04:43.168 --> 00:04:46.768
上一页演示中已经推断过, 这就是-1

50
00:04:46.774 --> 00:04:52.990
从这个恒等式, 我们了解到-x = ~x + 1

51
00:04:52.990 --> 00:04:57.993
这就把补码和反码表示联系其来了

52
00:04:58.004 --> 00:05:05.520
举个例子, 比如... 如果x等于这串常数

53
00:05:05.526 --> 00:05:12.006
x的反码或者说~x, 就是x所有位反转

54
00:05:12.011 --> 00:05:17.940
向x反码加1就得到-x

55
00:05:17.940 --> 00:05:26.495
加1, 其实是把从右开始的第一个0反转为1

56
00:05:26.495 --> 00:05:31.335
然后把它右侧所有的1反转为0

57
00:05:33.078 --> 00:05:39.377
还有另一种解释, 观察x的表示

58
00:05:39.377 --> 00:05:47.384
把从左到最右的1的所有位, 不包括这个1, 都反转就得到补码

59
00:05:49.159 --> 00:05:51.772
有疑问吗?

60
00:05:57.674 --> 00:06:07.294
这是二进制和十六进制表示的对应表

61
00:06:07.294 --> 00:06:13.896
使用十六进制的原因是, 有时候数字很大, 二进制表示过长

62
00:06:13.896 --> 00:06:18.100
我们根本不想在代码里写这么长串的数字

63
00:06:18.100 --> 00:06:23.069
而十六进制的表示则要紧凑的多

64
00:06:23.069 --> 00:06:31.159
你可以用这个表来找一个十六进制数对应的二进制是什么

65
00:06:31.159 --> 00:06:39.288
从0到9, 十六进制的表示和十进制是一样的

66
00:06:39.288 --> 00:06:46.032
对于10到15, 我们使用字母A到F代替

67
00:06:47.093 --> 00:06:53.419
而从十六进制转换为二进制, 只要查找这个表

68
00:06:53.419 --> 00:06:59.850
顺序写下对应二进制, 连在一起, 就是对应二进制表示

69
00:06:59.850 --> 00:07:06.239
比如有一个十六进制常数DEC1DE2C0DE4F00D

70
00:07:07.248 --> 00:07:11.970
现在我只需要查找每一个十六进制数对应什么

71
00:07:11.970 --> 00:07:18.940
所以D是1101, E是1110, C是1100, 以此类推

72
00:07:18.940 --> 00:07:24.833
把这些数字连起来就得到二进制表示

73
00:07:26.031 --> 00:07:30.617
你也可以反着来, 把二进制转换为十六进制

74
00:07:30.628 --> 00:07:33.315
手法是一样的, 查表就可以了

75
00:07:36.020 --> 00:07:39.890
前缀0x表明这是一个十六进制常数

76
00:07:39.890 --> 00:07:43.730
就像0b是二进制数的前缀一样

77
00:07:43.741 --> 00:07:50.024
所以如果你在使用这些常数, 在用十六进制写, 你应该加上0x前缀

78
00:07:55.194 --> 00:08:02.300
总的来说C有很多位运算符, 这是一张位运算符功能总结表

79
00:08:02.300 --> 00:08:13.271
&是与, ||是或, ^是XOR, 或者说异或

80
00:08:13.276 --> 00:08:18.797
XOR(异或)的意思是如果两个二进制位不同, 结果为1

81
00:08:18.803 --> 00:08:24.049
如果都是0, 都是1, 相同的话结果就是0

82
00:08:24.731 --> 00:08:30.364
~波浪号表示反码, 或者说取反

83
00:08:30.364 --> 00:08:34.512
还有左移和右移运算符

84
00:08:35.194 --> 00:08:39.530
来看些运算符的例子, 理解他们的功能吧

85
00:08:39.530 --> 00:08:42.311
我们有两个8位二进制数, A以及B

86
00:08:42.311 --> 00:08:49.868
运算A&B, 只需要关注AB同位置上的二进制位

87
00:08:49.868 --> 00:08:52.507
然后对这两位进行与运算

88
00:08:52.507 --> 00:08:57.004
1与0得0, 所以最左位是0

89
00:08:57.004 --> 00:08:58.998
0与1得0, 第二位也是0

90
00:08:58.998 --> 00:09:03.512
1与1得1, 第三位是1, 以此类推

91
00:09:03.512 --> 00:09:09.215
A|B也是类似的, 不过现在你要做的是或运算, 而不是与运算

92
00:09:09.215 --> 00:09:12.997
两位中只要有一位是1, 结果就是1

93
00:09:13.002 --> 00:09:14.894
如果两位都是0, 结果才是0

94
00:09:14.900 --> 00:09:20.310
所以A|B的话, 只有这一位是0

95
00:09:20.315 --> 00:09:26.016
因为原本两个数的这两位都是0

96
00:09:26.900 --> 00:09:32.197
对于x^B, 我们检查是否两位中只有一位是1

97
00:09:32.214 --> 00:09:37.348
对于最左的位置, 分别是1和0

98
00:09:37.354 --> 00:09:42.002
两位中只有一位是1, 所以第一位结果是1

99
00:09:42.002 --> 00:09:44.767
第二位是0和1, 所以结果是1

100
00:09:44.767 --> 00:09:48.040
第三位是两个1, 所以结果是0, 以此类推

101
00:09:48.653 --> 00:09:53.506
~A只是A的反码, 之前已经说明过了, 反转全部位就好

102
00:09:53.512 --> 00:10:05.496
右移三位, 就是所有位向右移动字串3个位置, 左侧空余填0

103
00:10:05.501 --> 00:10:13.055
左移两位, 和右移类似, 但这此是右测空余填0

104
00:10:15.234 --> 00:10:19.915
这是C语言的位运算符, 有问题吗?

105
00:10:28.160 --> 00:10:30.100
听众: 右移不应该是根据符号位填吗?

106
00:10:34.470 --> 00:10:36.871
JULIAN SHUN: 确实

107
00:10:36.877 --> 00:10:45.867
右移会在左侧空余填上符号位的值

108
00:10:45.884 --> 00:10:49.123
但如果你对无符号整数运算, 填的就只是0

109
00:10:49.129 --> 00:10:50.811
对有符号整数才会填符号位

110
00:10:51.269 --> 00:10:56.350
我们作位运算, 一般会假设运算对象就是无符号整数

111
00:10:56.350 --> 00:10:57.892
然后就不需要叨扰这个问题了

112
00:11:04.069 --> 00:11:09.290
那么先让我们学一些位运算常用用法

113
00:11:09.290 --> 00:11:14.548
第一个是把x的第k位设为1

114
00:11:15.105 --> 00:11:19.906
思路是先用位移, 再接一个或运算

115
00:11:19.912 --> 00:11:27.112
如果想要设k位, 那我们肯定要把1左移k位

116
00:11:27.123 --> 00:11:33.270
这么做能得到一个掩码, 第k位正好是1. 其他位都是0

117
00:11:33.276 --> 00:11:39.927
然后我们将它与x相或, 把x的第k位设为1, 如果它原来是0的话

118
00:11:39.927 --> 00:11:43.263
如果第k位原本就是1, 这条语句就没有实际效果

119
00:11:43.263 --> 00:11:50.740
对于其他位置来说, 因为是或运算, 所以会直接复制原有的值

120
00:11:51.342 --> 00:11:55.830
这是设置第k位, 当然我们也能清零第k位

121
00:11:55.830 --> 00:12:00.302
思路是先位移, 再取反, 最后用与运算

122
00:12:00.308 --> 00:12:04.699
又一次, 我们要右移k位生成一个掩码

123
00:12:05.123 --> 00:12:07.180
不过接下来要取反这个掩码

124
00:12:07.180 --> 00:12:13.010
所以除了第k位是0外, 其余位置都是1

125
00:12:14.139 --> 00:12:18.452
然后将掩码和x相与, 第k位就清零了

126
00:12:18.452 --> 00:12:25.572
因为我们在和0相与, 所以结果肯定是0, 不管原来是什么

127
00:12:25.572 --> 00:12:31.220
对于其余位置, 因为是和1与, 所以只是从原数字复制过来

128
00:12:36.620 --> 00:12:42.610
你可以用位移和异或来反转第k位

129
00:12:42.610 --> 00:12:48.920
再一次, 我们需要生成掩码, 然后用x和这个掩码异或

130
00:12:48.920 --> 00:12:55.498
它会把1变为0, 0变为1. XOR就是做这个的

131
00:12:56.072 --> 00:12:58.400
本例中, 它把1变为0了

132
00:12:58.400 --> 00:13:05.986
不过如果原本是0, 它会把结果设为1, 有问题吗?

133
00:13:12.175 --> 00:13:16.760
好, 下一个位运算技巧

134
00:13:16.760 --> 00:13:21.299
现在我们尝试获取x的第k位的值

135
00:13:21.299 --> 00:13:26.090
编码过的数据经常需要这么做

136
00:13:26.090 --> 00:13:29.594
思路是位移掩码生成一个新掩码

137
00:13:29.605 --> 00:13:41.003
我们需要一个除了想要提取的位置是1, 其余位置都是0的掩码

138
00:13:41.009 --> 00:13:49.285
然后我们将x和掩码相与, 这就获取了这四个期望位置的值

139
00:13:49.291 --> 00:13:56.950
而结果的其他位置都是0, 然后再右移这个结果

140
00:13:56.950 --> 00:14:05.497
使得获取的结果放在LSB(第0位)的位置上, 以便计算

141
00:14:06.610 --> 00:14:13.138
如果你在处理压缩/编码后的数据, 这个技巧很有用

142
00:14:13.143 --> 00:14:23.138
如果你使用C++的位成员功能, 其实会生成等价的掩码位移汇编

143
00:14:27.599 --> 00:14:30.496
你也可以设置x的一个位域

144
00:14:31.058 --> 00:14:36.002
比如说你想设置x的一个位域为y

145
00:14:36.185 --> 00:14:41.745
思路是首先取反掩码, 相与清除想要设置的位域

146
00:14:41.745 --> 00:14:44.567
最后和位移后的y相与

147
00:14:45.491 --> 00:14:50.071
假设, 我们有两个数字x和y

148
00:14:50.071 --> 00:14:57.016
和之前一样先生成掩码, 不过这次要取反所有位(反码)

149
00:14:57.021 --> 00:15:14.840
然后和x相与, 因为掩码对应位置为0, 所以清零了x对应位置

150
00:15:14.851 --> 00:15:19.161
对于其他所有位置, 都是复制原有值

151
00:15:21.299 --> 00:15:29.709
接着, 适当的左移y, 让y对齐待设置的4bit的位置

152
00:15:29.715 --> 00:15:36.890
最后相与, 就会把x中对应位置设置为y

153
00:15:44.475 --> 00:15:49.691
当然为了保证安全, 还得在y右移之后做一次与运算

154
00:15:49.691 --> 00:15:53.950
因为你不知道y的值是不是在掩码的区间内

155
00:15:53.950 --> 00:16:01.692
所以如果y有些无用位在掩码之外, 和x相与的时候就可能意外改变x的值

156
00:16:01.692 --> 00:16:08.880
为保安全, 一定要在或运算之前, 让y和掩码相与

157
00:16:14.923 --> 00:16:17.298
有疑问吗?

158
00:16:21.732 --> 00:16:24.710
现在让我们看看怎么交换两个整数的值

159
00:16:24.710 --> 00:16:27.622
我们的目标是交换x和y的值

160
00:16:29.096 --> 00:16:37.616
标准做法是用第三个值, t = x, x = y, y = t

161
00:16:40.306 --> 00:16:43.421
但这确实多用了一个临时变量

162
00:16:43.427 --> 00:16:47.998
所以我们能不能不靠临时变量来交换呢?

163
00:16:47.998 --> 00:16:50.885
答案是你可以用位运算技巧来做

164
00:16:51.808 --> 00:16:58.789
这是无临时交换的代码, 首先使x = x ^ y

165
00:16:58.795 --> 00:17:03.994
然后让y = x ^ y, 最后x = x ^ y

166
00:17:04.579 --> 00:17:08.210
有人见过这个技巧吗?

167
00:17:08.221 --> 00:17:10.572
所以你们有些人已经见过了, 非常好

168
00:17:11.008 --> 00:17:14.839
接下来几页演示, 我会告诉你们它的原理

169
00:17:14.839 --> 00:17:21.680
首先在搞懂原理之前, 先看看他的具体运行情况吧

170
00:17:21.680 --> 00:17:26.295
所以x和y的初始值如图所示

171
00:17:26.455 --> 00:17:33.372
最开始是x ^ y, 结果存入x

172
00:17:33.382 --> 00:17:37.487
这就是他俩运算的结果

173
00:17:37.492 --> 00:17:40.885
然后再把x ^ y赋值给y

174
00:17:40.891 --> 00:17:44.466
注意第二次运算的时候x的值已经变了

175
00:17:44.467 --> 00:17:49.313
对他们俩做以此异或, 赋值给y

176
00:17:49.663 --> 00:17:56.231
然后y的值就和x原来的值相同了, 已经把x置换到y了

177
00:17:56.237 --> 00:18:02.904
最后再做一次异或, 赋值给x

178
00:18:03.242 --> 00:18:06.430
得到结果, 和原来的y是一样的

179
00:18:06.430 --> 00:18:11.730
总结一下, 这些步骤成功的交换了x和y, 没有用临时变量

180
00:18:13.668 --> 00:18:18.802
它的原理是异或的逆就是异或本身

181
00:18:18.814 --> 00:18:24.692
如果你将x和y异或, 接着再与y异或, 你会得到原来的x

182
00:18:24.692 --> 00:18:27.800
让我们靠真值表探究一下

183
00:18:27.800 --> 00:18:36.687
在x列, y列中, 列出了所有可能的组合, 总共四种可能

184
00:18:37.301 --> 00:18:48.374
也有x ^ y的值, 两个中只有一个为1的行, 结果为1, 其余为0

185
00:18:48.391 --> 00:18:57.880
不过如果继续和y异或, 0 ^ 0 = 0

186
00:18:57.880 --> 00:19:03.872
1^1=0, 1^0=1, 0^1=1

187
00:19:03.872 --> 00:19:08.995
不过注意得到的值和原来的x一样

188
00:19:09.000 --> 00:19:16.410
也就是说如果异或相同的值两次, 就抵消了, 得到的原值

189
00:19:20.720 --> 00:19:25.885
现在说说为什么这么做可以置换

190
00:19:26.603 --> 00:19:35.240
第一行, 我们做的其实是生成一个x和y不同位为1的掩码

191
00:19:35.245 --> 00:19:40.681
这是XOR的定义, 如果两位不同结果为1, 否则为0

192
00:19:40.681 --> 00:19:46.614
所以这个掩码包含了x和y哪里不同的信息

193
00:19:48.254 --> 00:19:50.562
这个值会存入x

194
00:19:50.573 --> 00:19:59.109
第二行, 会反转y中和原x不同的bit, 因为你在用y和掩码异或

195
00:19:59.114 --> 00:20:10.580
而掩码包含不同位的信息, 所以异或会反转y不同于x的位

196
00:20:10.580 --> 00:20:20.006
这就得到了x, 然后赋值给y, 现在y中存储x原来的值

197
00:20:20.018 --> 00:20:24.920
最后一行做的事情类似, 但是这次反转了x中不同于y的bit

198
00:20:24.920 --> 00:20:33.271
掩码存储在x中, 和y中原来的x值进行异或

199
00:20:33.276 --> 00:20:41.081
就反转了x中不同于y的bit, 得到了原来y的值, 赋值给了x

200
00:20:43.881 --> 00:20:46.465
很炫酷的技巧, 不是吗?

201
00:20:47.377 --> 00:20:50.782
对它的原理有疑问吗?

202
00:20:57.643 --> 00:21:05.228
所以这个技巧的一个问题是, 它对于指令级并行很不友好

203
00:21:05.228 --> 00:21:10.278
所以其实比用临时变量的方法慢

204
00:21:10.640 --> 00:21:16.910
因为原有的代码, 可以同时指令前两行

205
00:21:16.910 --> 00:21:22.751
我可以存放临时变量, 同时改变x或者y其中一个的值

206
00:21:23.215 --> 00:21:30.719
而这份代码, 三行都有数据依赖, 无法并行执行

207
00:21:31.034 --> 00:21:41.870
之后几周我们会学习指令级并行, 现在我只想指出这技巧变慢了

208
00:21:41.870 --> 00:21:47.642
但这个技巧很酷, 有些面试也会问

209
00:21:52.293 --> 00:22:00.499
下一个技巧是, 找到两个整数中小的那个

210
00:22:01.509 --> 00:22:06.024
所以我们的目标是把小的那个存入变量r中

211
00:22:06.707 --> 00:22:11.243
标准做法是使用一个if-else语句

212
00:22:11.254 --> 00:22:16.486
如果x<y, r=x, 否则r=y

213
00:22:17.289 --> 00:22:21.840
存在使用三元运算符的等价表达式

214
00:22:21.840 --> 00:22:25.476
它和左侧if-else语句功能一致

215
00:22:31.366 --> 00:22:34.960
这种代码的一个问题是, 这创造了一个分支

216
00:22:34.960 --> 00:22:39.344
有一个if语句检查x是否小于y

217
00:22:39.895 --> 00:22:46.570
现代机器都会做分支预测, 预测代码会选哪个分支

218
00:22:46.570 --> 00:22:50.503
那需要提前解析, 执行一些指令

219
00:22:50.675 --> 00:22:57.064
问题是如果它预测分支失败, 它就做了很多无用功

220
00:22:57.081 --> 00:23:01.588
处理器就必须重置流水线, 然后撤销做过的许多工作

221
00:23:01.788 --> 00:23:06.541
这是分支预测失败造成的性能问题

222
00:23:07.941 --> 00:23:15.711
现代编译器一般有能力消去这个分支, 但有时候不行

223
00:23:15.717 --> 00:23:19.967
有没有找到最小值, 又不用分支的办法呢?

224
00:23:23.240 --> 00:23:25.511
答案是有, 这就是方法

225
00:23:25.683 --> 00:23:33.244
令r = y ^ ( (x^y) & -(x < y))

226
00:23:34.029 --> 00:23:35.992
很明显对吧?

227
00:23:39.028 --> 00:23:42.018
所以原理是什么呢?

228
00:23:42.959 --> 00:23:51.011
首先你得知道c语言中布尔值真/假分别用整数1/0表示

229
00:23:52.003 --> 00:24:00.553
总共有两种可能情况, 首先看看x<y的情况, 然后x >= y的情况

230
00:24:00.559 --> 00:24:08.660
所以当x<y时, x < y的结果是1

231
00:24:08.660 --> 00:24:11.625
我们取反它, 得到-1

232
00:24:11.631 --> 00:24:18.620
如之前所言, 补码表示中-1就是所有位都是1

233
00:24:18.643 --> 00:24:26.997
也就是将x^y和-1相与, 得到x^y本身

234
00:24:27.651 --> 00:24:37.858
最后就是y和x^y异或, 然后我们知道异或的逆就是异或

235
00:24:37.864 --> 00:24:42.201
因此两个y消除了, 只剩下了x

236
00:24:42.212 --> 00:24:45.016
而这确实是这种情况下的最小值

237
00:24:48.178 --> 00:24:52.008
另一种情况下x >= y

238
00:24:52.381 --> 00:24:57.188
那x < y的结果是0, -0仍然是0

239
00:24:57.618 --> 00:25:01.760
将x ^ y和0相与得到还是0

240
00:25:01.778 --> 00:25:08.882
最后是y ^ 0, 结果是y, 而这就是这种情况下的最小值

241
00:25:10.974 --> 00:25:12.711
有任何问题吗?

242
00:25:20.710 --> 00:25:23.652
有多少人已经知道这个技巧了?

243
00:25:26.730 --> 00:25:28.748
非常好, 所以我们今天学了些新东西

244
00:25:29.820 --> 00:25:36.405
让我们看看函数中分支到底是怎么工作的

245
00:25:36.422 --> 00:25:43.481
我们的目的是合并两个有序数组, 你可能知道, 这是归并排序的一个子过程

246
00:25:44.198 --> 00:25:51.899
这个函数的输入是三个数组, 我们想合并A和B, 结果存入C

247
00:25:51.916 --> 00:25:57.221
数组A, 数组B的大小分别是na, nb

248
00:25:59.438 --> 00:26:02.590
restrict关键字的作用是什么, 有人知道么?

249
00:26:07.819 --> 00:26:16.222
好吧, restrict关键字告诉编译器, 这是唯一一个指向那片内存的指针

250
00:26:16.653 --> 00:26:20.135
这让编译器可以做更多指针优化工作

251
00:26:20.135 --> 00:26:26.236
如果你知道你写的程序中, 只有一个指针指向那片内存

252
00:26:26.242 --> 00:26:32.517
那你就可以声明restrict关键字, 这给了编译器更多优化空间

253
00:26:35.635 --> 00:26:43.547
现在让我们看看这个过程, 如果AB数组的大小都不是0

254
00:26:43.569 --> 00:26:53.599
程序就会执行if-else语句, 检查A指向的元素是否小于B指向的元素

255
00:26:53.708 --> 00:27:03.681
如果小于, 就把A中元素存入C, 然后同时自增指针A和C, 并自减na

256
00:27:04.083 --> 00:27:08.519
那么A中需要合并的元素就少了一个

257
00:27:08.978 --> 00:27:14.066
否则, 对数组指针B和nb做同样的事情

258
00:27:14.077 --> 00:27:22.006
只要其中数组变空, 就会执行下面两个循环中的一个

259
00:27:22.029 --> 00:27:26.972
下面两个循环只是把剩下的那个非空数组的剩余运算全部存入C

260
00:27:26.972 --> 00:27:34.470
所以如果na大于0, A就是非空的, 就把A中剩余存入C

261
00:27:34.487 --> 00:27:37.730
否则, 就把B中元素存入C

262
00:27:37.730 --> 00:27:45.255
让我们看个实例, 比如把这两个绿色的数组归并为蓝色的数组

263
00:27:45.266 --> 00:27:51.512
规定上面的数组是A, 下面的是B, 蓝色的是C

264
00:27:51.815 --> 00:27:57.070
所以最初A和B都指向这两个绿色数组的开头

265
00:27:57.076 --> 00:28:03.521
因为两个数组非空, 所以我们要比较前两个元素

266
00:28:03.825 --> 00:28:08.477
可以看到3小于4, 所以3放到C中

267
00:28:08.483 --> 00:28:12.810
接着自增指针A, 指向下一个元素

268
00:28:12.810 --> 00:28:17.508
当然也要自增C, 指向下一个空闲位置

269
00:28:17.989 --> 00:28:23.904
接着我们要比较4和12, 4小于12, 所以4存入数组C

270
00:28:23.910 --> 00:28:28.153
然后自增B, 等等, 以此类推

271
00:28:28.440 --> 00:28:38.280
所以12小于14, 14小于19, 19小于21, 21小于46, 23小于46

272
00:28:38.280 --> 00:28:42.350
这个时候, B数组变空了

273
00:28:42.780 --> 00:28:51.090
然后进入第二个循环, 可以看到A还剩元素, 存入C就大功告成

274
00:28:54.990 --> 00:28:59.528
这是合并两个数组标准的方式

275
00:29:02.664 --> 00:29:06.508
现在来看看分支预测的情况

276
00:29:06.508 --> 00:29:13.591
一个分支如果多数时候走向相同, 就说它是可预测的

277
00:29:13.603 --> 00:29:16.445
也就是说, 偶尔才会进入一个不同的分支

278
00:29:16.451 --> 00:29:24.004
而不可预测分支有时进入第一个, 有时进入第二个, 没办法预测

279
00:29:25.002 --> 00:29:30.331
首先看看第一个分支, 有人能回答一下它可不可预测吗?

280
00:29:37.200 --> 00:29:42.524
听众: 不可预测. 因为和输入是有关系的

281
00:29:43.287 --> 00:29:46.834
JULIAN SHUN: 其实这个分支是可预测的

282
00:29:46.834 --> 00:29:50.745
因为大多数时候它的结果都是true, 除了最后一次

283
00:29:51.153 --> 00:29:54.750
它只有nb等于0时, 才会返回false

284
00:29:54.750 --> 00:29:58.239
那个时候你只需要执行最后一次, 然后就结束了

285
00:29:58.635 --> 00:30:06.611
但多数时候, nb是大于0的, 所以这是个可预测分支

286
00:30:09.516 --> 00:30:12.187
那么第二个呢?

287
00:30:16.233 --> 00:30:18.322
听众: 也是可预测的?

288
00:30:18.322 --> 00:30:21.190
JULIAN SHUN: 没错, 和之前的原因相同

289
00:30:24.474 --> 00:30:26.130
那么第三个呢?

290
00:30:30.755 --> 00:30:31.630
听众: 不可预测

291
00:30:31.630 --> 00:30:37.412
因为如果我们知道哪个大的话, 那数组就已经排序好了

292
00:30:37.412 --> 00:30:39.890
JULIAN SHUN: 没错, 所以这个是不可预测的

293
00:30:39.890 --> 00:30:43.498
因为我们先前不知道A和B中的值

294
00:30:44.048 --> 00:30:52.430
所以这个if语句中的条件真假可能性五五开

295
00:30:52.430 --> 00:30:57.170
既然不知道A和B数组的值, 那肯定就是个不可预测分支了

296
00:30:57.170 --> 00:31:02.499
进入两边分支的概率一半一半

297
00:31:03.520 --> 00:31:05.675
最后一个呢?

298
00:31:05.692 --> 00:31:06.192
听众: 可预测

299
00:31:06.214 --> 00:31:07.554
JULIAN SHUN: 原因?

300
00:31:07.583 --> 00:31:14.854
听众:和分支1, 2类似, 因为大概率na, nb大于0

301
00:31:15.088 --> 00:31:17.416
JULIAN SHUN: 没错, 所以它可预测

302
00:31:17.668 --> 00:31:27.496
因为多数时候为真, 如果是假, 循环就结束了, 再也不会执行以下代码了

303
00:31:27.565 --> 00:31:33.501
所以多数时候条件都是真, 这个分支可预测

304
00:31:34.270 --> 00:31:41.020
分支1, 2, 4都可预测, 没问题, 但是分支3有问题

305
00:31:41.381 --> 00:31:50.507
它不可预测, 所以硬件不友好, 因为硬件不能效率的预读取

306
00:31:51.304 --> 00:31:58.000
为了修正这个问题, 可以使用前几页演示中的位运算技巧

307
00:31:58.499 --> 00:32:10.213
现在先声明一个变量cmp, 赋值A和B第一个运算比较的结果

308
00:32:10.225 --> 00:32:17.035
然后用下面的语句获取最小值, 这和之前讲的技巧一样

309
00:32:19.404 --> 00:32:26.604
所以现在min存储着A和B第一个运算中比较小的那一个

310
00:32:26.604 --> 00:32:33.195
以及cmp中存储着两值比较的结果

311
00:32:33.201 --> 00:32:38.710
首先我们把最小值存入C, 然后根据cmp的值

312
00:32:38.710 --> 00:32:45.423
我们会自增A或B中的一个, 如果A的第一个值小于等于B, cmp等于1

313
00:32:45.670 --> 00:32:52.360
所以A += cmp, 会让A自增1

314
00:32:52.360 --> 00:32:57.570
而B += !cmp不会改变B的值, 因为!cmp结果为0

315
00:32:57.576 --> 00:33:01.180
对于na, 我们用cmp自减

316
00:33:01.180 --> 00:33:05.703
如果A小于B, 就会减去1, 否则减去0

317
00:33:05.709 --> 00:33:09.705
对于np, 我们用!cmp自减

318
00:33:09.717 --> 00:33:17.511
所以这两行, 根据cmp的值, 只有一行会真的起效果

319
00:33:18.176 --> 00:33:24.990
其余代码和之前一样, 有问题吗?

320
00:33:25.678 --> 00:33:29.670
所以之前的不可预测分支被消除了

321
00:33:33.478 --> 00:33:38.037
但是这个优化, 经常只在某些特定机器上起效

322
00:33:38.180 --> 00:33:44.576
但是, 在现代机器上, 搭配一个好编译器, 比如clang -O3

323
00:33:44.690 --> 00:33:48.530
这个无分支版本通常比分支版本还要慢

324
00:33:48.530 --> 00:33:55.995
因为编译器足够智能, 知道如何优化获取最小值的分支

325
00:33:56.018 --> 00:34:00.269
有一个cmov指令, 或者说条件移动指令

326
00:34:00.883 --> 00:34:07.976
它就是一个无分支的比较语句, 下周我们会学习

327
00:34:08.309 --> 00:34:11.186
所以这个技巧一般不奏效

328
00:34:11.542 --> 00:34:14.000
也许有些机器和编译器上, 这个技巧起作用

329
00:34:14.000 --> 00:34:18.489
但大多数时候, 编译器优化的都比你要好

330
00:34:19.493 --> 00:34:25.179
到现在为止, 情形差不多是我教给你一个很酷的位运算技巧

331
00:34:25.190 --> 00:34:28.124
然后又告诉你它实际意义不大

332
00:34:28.141 --> 00:34:33.264
所以为什么我们要学习位运算? 如果他们意义不大的话?

333
00:34:33.648 --> 00:34:39.770
第一个原因是编译器会做这些技巧, 理解位运算才能理解编译器

334
00:34:39.770 --> 00:34:45.009
阅读编译器生成的汇编代码时才会懂

335
00:34:45.027 --> 00:34:50.968
第二, 有时侯编译器不会帮你做, 你需要亲手做这些优化

336
00:34:51.369 --> 00:34:59.530
第三, 许多作用于字的技巧也可以推广到向量上, 高性能编程中用的很多

337
00:34:59.530 --> 00:35:05.005
所以了解这些技巧没坏处, 它们也在其他领域中出现

338
00:35:05.464 --> 00:35:09.047
而且, 它们本身也很有意思

339
00:35:09.506 --> 00:35:18.008
而项目1中, 你就需要这些位运算技巧, 所以了解我讲的技巧没有坏处

340
00:35:19.023 --> 00:35:22.186
现在, 我们来说一些有实际意义的位运算技巧

341
00:35:22.685 --> 00:35:30.420
我们的目标是同余加法, 也就是(x + y) mod n

342
00:35:30.420 --> 00:35:38.485
假定x和y都大于等于0, 小于n

343
00:35:38.490 --> 00:35:44.998
标准做法是使用取余运算符, (x+y)%n

344
00:35:44.998 --> 00:35:52.515
不过这个运算会做一次昂贵的除法运算, 除非n是二次幂

345
00:35:52.515 --> 00:35:57.100
但一般来说, 编译时, 编译器不知道n是不是二次幂

346
00:35:57.100 --> 00:36:04.994
所以编译器不会优化成位移运算符, 而是会做一次除法

347
00:36:05.028 --> 00:36:15.003
其实有另一种不需要除法的方法, 首先令z等于x+y

348
00:36:15.014 --> 00:36:21.469
如果z < n, 那结果已经在范围内了, 直接返回即可

349
00:36:21.486 --> 00:36:29.260
如果z >= n, 因为x和y最多n-1, 所以这个数字最多2n - 2

350
00:36:29.271 --> 00:36:34.010
所以我们只需要减去n, 让他小于n就好

351
00:36:34.985 --> 00:36:41.509
但是这串代码有一个不可预测分支, 因为我们不知道z是否小于n

352
00:36:41.514 --> 00:36:44.875
所以我们可以使用最小值的位运算技巧

353
00:36:45.265 --> 00:36:53.545
现在令r等于z - (n & -(z >= n))

354
00:36:55.380 --> 00:37:00.770
如果z < n, 这里的结果就是0

355
00:37:00.770 --> 00:37:03.670
所以n与0得0, 结果只剩下z

356
00:37:03.670 --> 00:37:09.330
如果z >= n, 这里的结果就是1

357
00:37:09.330 --> 00:37:12.667
取反得到-1, 所有位都是1

358
00:37:13.074 --> 00:37:19.980
n和-1相与还是n, 所以是z - n, 就把结果降到范围内了

359
00:37:24.549 --> 00:37:29.523
有问题吗?

360
00:37:29.570 --> 00:37:37.760
听众: 我觉得这本质上是一个基于z的值的分支, 为什么变快了呢?

361
00:37:37.760 --> 00:37:42.409
JULIAN SHUN: 你说的这个分支, 其实只是生成布尔值1或者0

362
00:37:42.427 --> 00:37:46.666
其实后面还有代码, 而现在不管条件如何, 执行的都是同一套代码

363
00:37:47.085 --> 00:37:51.570
分支预测失败, 只有在可能分支后执行两套不同代码才会降低性能

364
00:37:51.570 --> 00:37:58.222
上面的这个版本中, 就有两套不同代码, 一个要赋值z, 一个z-n

365
00:38:02.511 --> 00:38:09.610
下一个问题是计算最接近的2次幂

366
00:38:09.610 --> 00:38:14.518
也就是计算lgn向上取整的2次幂

367
00:38:14.937 --> 00:38:21.999
另外, lg n中底数为2, 这堂课以后也会用这种记号

368
00:38:22.503 --> 00:38:28.070
这是解决代码, n的值在这儿

369
00:38:28.070 --> 00:38:30.273
首先我们需要自减n

370
00:38:30.290 --> 00:38:35.328
接着用n和n右移1位的结果进行或运算

371
00:38:35.328 --> 00:38:40.347
然后和右移2位的进行或运算, 以此类推直到32

372
00:38:40.370 --> 00:38:47.383
做到位移32位之后, 最后, 自增n

373
00:38:47.400 --> 00:38:50.486
来看个例子, 想想是怎么回事吧

374
00:38:50.503 --> 00:38:53.710
n的初值如图所示

375
00:38:56.372 --> 00:39:06.844
首先自减, 反转最右的1为0, 再把之后所有的0反转为1

376
00:39:09.284 --> 00:39:16.464
接着执行n |= n >> 1

377
00:39:16.475 --> 00:39:22.006
也就是和向右位移1位的自己相或

378
00:39:22.058 --> 00:39:26.560
本质上就是把所有的1向右再复制一个

379
00:39:26.560 --> 00:39:29.191
这些是1的bit全都向右复制了一份

380
00:39:29.380 --> 00:39:34.499
右侧的这些1也在复制, 不过因为已经全部都是1, 所以无实际效果

381
00:39:35.049 --> 00:39:39.485
下一行我们把所有的1向右复制2位

382
00:39:40.030 --> 00:39:46.590
所以这个1复制到了这里, 那个1复制到了那里, 以此类推

383
00:39:47.164 --> 00:39:53.380
下一行把1向右复制了4位. 然后8位, 16位, 32位

384
00:39:53.380 --> 00:39:57.440
对于这个例子来说, 执行到这儿就已经结束了

385
00:39:57.440 --> 00:40:03.007
但一般你的字里有更多bit, 放不进这页演示中

386
00:40:04.355 --> 00:40:09.165
现在, 这个结果正好比2次幂少1

387
00:40:09.481 --> 00:40:12.010
把1加上去, 我们就得到二次幂

388
00:40:12.010 --> 00:40:16.330
也就是把所有1都设为0, 然后把1放在最右第一个0处

389
00:40:16.330 --> 00:40:21.498
这恰好是比n大的第一个2次幂

390
00:40:28.770 --> 00:40:35.532
第一行其实是保证第lgn -1位一定是1

391
00:40:35.532 --> 00:40:42.491
因为我们想要那一位复制到它右侧所有位置上

392
00:40:43.833 --> 00:40:49.013
而这六行, 把所有的1的右侧都填满1

393
00:40:49.626 --> 00:40:55.512
最后讲第lg n位设置为1, 把其他所有位清零

394
00:40:58.214 --> 00:41:02.522
所以为什么我们最开始需要-1?

395
00:41:06.287 --> 00:41:08.462
听众: 以防n已经是2次幂

396
00:41:08.462 --> 00:41:09.308
JULIAN SHUN: 没错

397
00:41:09.308 --> 00:41:14.495
如果n已经2次幂, 我们还没有自减, 这个技巧就失败了

398
00:41:14.495 --> 00:41:17.142
因为第lgn-1位可能不是1

399
00:41:17.154 --> 00:41:22.533
但如果减1, 就可以保证第lgn-1位是1

400
00:41:22.539 --> 00:41:24.920
然后就可以把它复制到右边了

401
00:41:28.372 --> 00:41:31.430
有什么问题吗?

402
00:41:31.930 --> 00:41:33.981
听众: [听不清]?

403
00:41:34.423 --> 00:41:39.015
JULIAN SHUN: 因为一般你用的是64位整数

404
00:41:39.032 --> 00:41:43.210
这儿我没有写出那么多bit, 因为演示页放不下

405
00:41:43.210 --> 00:41:45.297
但一般来说, 你肯定有更多bit

406
00:41:51.351 --> 00:41:53.238
下一个问题

407
00:41:53.250 --> 00:41:58.527
计算一个字中最右侧的1的掩码

408
00:41:58.538 --> 00:42:05.523
也就是计算一个掩码, 只有一位是1, 那一位恰好是x中最右的1的位置

409
00:42:05.524 --> 00:42:13.526
要怎么做呢? 可以令r = x & -x

410
00:42:15.403 --> 00:42:19.979
让我们探究一下原理, 这是x的值

411
00:42:19.984 --> 00:42:27.200
回忆-x其实是x的反码加1

412
00:42:27.200 --> 00:42:36.628
也就是反转所有bit, 直到最右侧的1, 但不包括它, 剩下的直接复制

413
00:42:36.634 --> 00:42:40.369
这是从x得到-x

414
00:42:40.380 --> 00:42:55.340
然后比较一下x和-x, 所有相与的bit结果都是0, 除了最右的1的位置

415
00:42:55.363 --> 00:43:00.524
那一位是1和1相与得1, 其余所有位结果都是0

416
00:43:00.541 --> 00:43:03.107
这就得到了想要的掩码

417
00:43:06.837 --> 00:43:13.611
因为-x就是x的反码加1, 所以这个技巧可行

418
00:43:18.905 --> 00:43:23.390
另一个问题是, 你怎么知道它是第几位?

419
00:43:23.390 --> 00:43:33.106
我只是生成了一个那一位为1的掩码, 但这不能告诉我它在第几位

420
00:43:33.111 --> 00:43:37.323
换句话说, 我想知道lg x, 其中x是二次幂

421
00:43:39.818 --> 00:43:45.401
我们要解决的问题, 而这是代码

422
00:43:45.419 --> 00:43:51.024
我们有一个Bruijn常数, 他用十六进制写在这里

423
00:43:51.024 --> 00:43:56.850
然后我们有一个长度64, 叫做convert的查询表

424
00:43:56.850 --> 00:44:06.624
需要做的只是乘上常数, 向右移动58位, 以此查表

425
00:44:06.641 --> 00:44:12.078
这就得到了一个二次幂的对数结果, 有问题吗?

426
00:44:18.169 --> 00:44:25.088
这的确看起来像是魔法, 所以以魔法之名, 我们先做一个数学魔术

427
00:44:25.111 --> 00:44:32.656
为了做这个魔术, 我需要五个志愿者, 只需要跟随指令就好

428
00:44:32.690 --> 00:44:49.103
有人愿意做志愿者吗?1, 2, 3,4, 再来一个, 5, 好, 过来吧, 站成一排

429
00:44:52.266 --> 00:44:54.619
只要站在这儿就行

430
00:45:03.671 --> 00:45:08.491
你们能稍微向左靠一靠吗, 非常好

431
00:45:08.493 --> 00:45:15.000
所以今天荣幸有请Jess Ray, The Golden "Ray"tio

432
00:45:15.012 --> 00:45:21.984
加入课堂, 来表演这个魔术. 让我们鼓掌欢迎

433
00:45:24.918 --> 00:45:28.670
JESS RAY: 今天我会给你们表演个小魔术

434
00:45:28.670 --> 00:45:35.038
我将读取你们的内心, 这不太可信, 但我希望能成功

435
00:45:35.795 --> 00:45:43.025
马上我就会表演, 但是首先, 读心之前需要除灵

436
00:45:43.025 --> 00:45:46.430
让所有不好的, 坏的东西全都走掉

437
00:45:46.430 --> 00:45:50.155
我需要你们大家帮我做一做这件事

438
00:45:50.167 --> 00:45:53.994
首先, 我有一个精致的小铃铛, 谁想要摇铃铛?

439
00:45:54.022 --> 00:45:55.327
听众: 我试试看

440
00:45:55.338 --> 00:45:56.866
JESS RAY: 好的, 可以先拿住一会吗?

441
00:45:56.877 --> 00:46:01.342
所以这个铃铛会消除所有的怨念, 可以摇一下吗?

442
00:46:01.359 --> 00:46:08.060
非常好, 这个听起来刺耳的铃声实际上正在帮我们驱灵

443
00:46:08.060 --> 00:46:12.118
以便让我可以读心, 谢谢你, 不用摇了

444
00:46:15.070 --> 00:46:21.021
好的, 接下来是这个魔术鼓,哪一位来晃一下它?

445
00:46:21.038 --> 00:46:26.560
多转几下, 转它, 用你的手腕转它, 这么做

446
00:46:26.560 --> 00:46:30.410
就是这样! 非常好, 完美

447
00:46:30.410 --> 00:46:32.770
现在感觉空气清净多了

448
00:46:32.770 --> 00:46:38.507
我可以开始读心了, 不用担心, 我不会告诉别人你在想什么

449
00:46:38.507 --> 00:46:44.989
看看我还有什么道具, 这个也许能让我连接精神, 帮我读心

450
00:46:45.012 --> 00:46:52.350
感觉很好, 所以我现在就要 开 始 读 心

451
00:46:52.350 --> 00:46:57.520
我会发给你们一些卡片, 然后我会说出你拿的是哪张卡片

452
00:46:57.520 --> 00:47:02.440
这是那些卡片, 好吧, 好像稍微有点小

453
00:47:02.440 --> 00:47:05.432
恩... 还能再大点

454
00:47:05.438 --> 00:47:12.430
哈, 用这个吧, 看起来舒服多了

455
00:47:13.601 --> 00:47:22.082
但这个有点重, 把这些垃圾都扔掉... 扔掉...

456
00:47:22.919 --> 00:47:29.621
搭把手, 我想要你像这样切牌, 洗牌

457
00:47:29.633 --> 00:47:34.810
对, 就这样洗牌就好, 只要不是真的随机洗牌

458
00:47:37.228 --> 00:47:38.572
听众: 好了, 就这样

459
00:47:38.572 --> 00:47:42.910
JESS RAY: 非常好, 现在我给你们没人一张牌, 别让我看到

460
00:47:42.910 --> 00:47:44.770
你自己可疑随便看

461
00:47:50.176 --> 00:47:52.660
最后一张, 完成

462
00:47:52.660 --> 00:47:59.050
我穿着的这件帅气连体衣可以掌握蒸发坏事物

463
00:47:59.050 --> 00:48:01.000
但我现在字面上的出汗(和上文蒸发同词)了

464
00:48:01.000 --> 00:48:08.984
但是要完成魔术, 还缺一顶.... 魔法帽子!

465
00:48:09.443 --> 00:48:12.948
好吧... 看看合不合"头", 看样子行

466
00:48:12.948 --> 00:48:15.883
开关哪去了, 啊, 这儿

467
00:48:15.917 --> 00:48:20.460
好了, 我准备好了, 你们准备好了吗?

468
00:48:21.028 --> 00:48:24.103
我确实需要点额外信息才能让魔术成功, 所以...

469
00:48:24.103 --> 00:48:27.386
如果你们拿得是红色卡牌, 可以举起手吗?

470
00:48:29.465 --> 00:48:31.202
没有吗?

471
00:48:31.202 --> 00:48:33.720
谁拿的红色卡牌, 红色

472
00:48:33.720 --> 00:48:36.054
你拿得不是红色吗? 好吧

473
00:48:36.513 --> 00:48:42.630
所以第一个和第三个... 嗯... 让我开始发动读心能力

474
00:48:42.630 --> 00:48:45.420
现在我要从左到右说出你们拿的卡牌

475
00:48:45.420 --> 00:48:51.920
很明显, 我知道颜色, 但我还要说出到底是哪种花色, 以及什么数字

476
00:48:52.493 --> 00:49:00.403
所以我知道你拿的是红色, 嗯.... 我感觉到一个方块, 还有一个4

477
00:49:00.403 --> 00:49:01.320
听众: 的确是

478
00:49:01.326 --> 00:49:06.870
JESS RAY: 赞, 很好, 是个好开头

479
00:49:09.814 --> 00:49:18.504
让我看看第二张是什么.... 我知道你有张黑色的卡牌

480
00:49:19.800 --> 00:49:27.300
让我看看, 黑桃, 是黑桃A吗?

481
00:49:27.300 --> 00:49:29.120
哈, 又说中一个

482
00:49:34.340 --> 00:49:40.952
又是一张红色.... 这张牌, 我看看...

483
00:49:40.981 --> 00:49:45.710
红色, 方块2

484
00:49:45.710 --> 00:49:48.995
好, 非常好, 目前为止都是对的, 最后两个能对上吗?

485
00:49:51.652 --> 00:49:59.750
让我看看.... 黑色, 梅花4

486
00:50:00.350 --> 00:50:04.550
好, 最后一个!

487
00:50:06.160 --> 00:50:08.022
啊... 这个稍微有点难

488
00:50:09.929 --> 00:50:16.029
黑色, 黑桃8

489
00:50:21.371 --> 00:50:27.478
如果有时间, 我可以继续装神弄鬼, 把剩下的卡牌都过一遍, 不过到此为止

490
00:50:27.484 --> 00:50:32.201
谢谢大家, 希望你们有被惊到

491
00:50:32.747 --> 00:50:36.084
哦, 对, 让我回收一下卡牌

492
00:50:39.747 --> 00:50:42.018
谢谢, 好的, 谢谢

493
00:50:42.028 --> 00:50:45.022
终于不用穿这个了, 一直流汗

494
00:50:51.688 --> 00:50:53.666
JULIAN SHUN: 相当有意思, 不是吗?

495
00:50:56.450 --> 00:50:58.295
所以到底是怎么回事?

496
00:51:00.848 --> 00:51:07.102
为了明白,原理首先需要学习Bruijn序列 

497
00:51:07.830 --> 00:51:14.064
长度为2^k的deBruijn序列s, 是一个循环的0/1序列

498
00:51:14.069 --> 00:51:24.466
其中2^k个长度为k的0/1字符串, 序列s有且仅有一个这样子序列

499
00:51:25.470 --> 00:51:28.712
这个定义很长, 看个例子吧

500
00:51:28.735 --> 00:51:32.508
这是一个k=3的Bruijn序列

501
00:51:32.508 --> 00:51:38.039
2^3=8, 所以序列长度为8

502
00:51:38.044 --> 00:51:50.230
可以看到所有可能的3位字符串都只在这个长度为8的循环序列中出现一次

503
00:51:50.241 --> 00:51:55.523
它循环的方式是到尾部就接上头部

504
00:51:55.540 --> 00:52:02.751
如你所见000从第0位开始, 001从第1位开始

505
00:52:02.757 --> 00:52:10.293
010从第6位开始, 011从第2位开始

506
00:52:10.660 --> 00:52:19.190
100在第7位, 101第5位, 110第4位, 111第3位

507
00:52:19.190 --> 00:52:26.997
所有长度为3的子序列都只在Bruijn序列中出现一次

508
00:52:29.416 --> 00:52:36.159
现在我要做一个长度为8的转换表

509
00:52:36.359 --> 00:52:40.010
一般来说这个表就是2^k这么长, 现在k=3

510
00:52:40.010 --> 00:52:54.110
转换表中, 我们存储的是deBruijn序列中那个子序列对应的起始为止

511
00:52:54.110 --> 00:53:05.997
所以表中2处存放的是6, 因为2, 也就是010在Bruijn序列中第6位

512
00:53:06.009 --> 00:53:15.086
然后4对应的是7, 因为100在Bruijn序列中第7位

513
00:53:17.211 --> 00:53:25.490
有了这张表, 我们就可以计算lg n(其中n为二次幂)

514
00:53:25.490 --> 00:53:27.922
希望你们还没忘记原本的目的

515
00:53:30.980 --> 00:53:39.410
所以我们要用deBruijn序列乘以这个二次幂

516
00:53:39.410 --> 00:53:43.480
比如我们要乘以16, 也就是2^4

517
00:53:43.480 --> 00:53:47.001
用2^4乘以deBruijn序列

518
00:53:47.019 --> 00:53:52.483
当乘以2^4次时, 那相当于在做左位移

519
00:53:52.500 --> 00:53:58.006
所以我们把deBruijn序列左移四位

520
00:53:58.029 --> 00:54:05.480
然后我们想知道出现在序列开头的是八个子序列中的哪一个

521
00:54:05.480 --> 00:54:10.976
左位移之后, 出现在序列开头的是110

522
00:54:11.945 --> 00:54:17.004
通过右移5位, 我们可以把这个子序列提取出来

523
00:54:17.033 --> 00:54:27.528
而110就是6, 我们可以查表看6是从哪出现的

524
00:54:27.539 --> 00:54:42.502
可以看到6对应4, 所以110出现在第4位, 这意味着我们刚才左移了4位

525
00:54:42.507 --> 00:54:53.983
这就告诉我们lgn的结果了, 因为我们左移4位的原因肯定是n = 2 ^ 4

526
00:54:54.533 --> 00:54:59.360
整个程序就范回了lg n的结果

527
00:55:02.660 --> 00:55:13.641
不过有一点很重要, 这个序列必须从全0开始, 因为我们要表示一个循环序列

528
00:55:14.260 --> 00:55:21.190
你需要确保, 左移的时候右侧填充的值是正确的

529
00:55:21.190 --> 00:55:30.100
注意第6位和第7位, 溢出的时候最后这里需要填0

530
00:55:30.100 --> 00:55:38.525
因为deBruijn序列从全0开始, 所以左移之后右侧自动填0, 子序列才正确

531
00:55:38.548 --> 00:55:45.999
而jess做的魔术有32张牌, k的值是5

532
00:55:46.744 --> 00:55:53.328
卡牌排列成了一个长度32的deBruijn序列

533
00:55:53.345 --> 00:56:00.396
每张牌都对应一个5bit的子序列

534
00:56:00.402 --> 00:56:08.359
而卡牌的颜色和bit有关, 所以她问你卡牌的颜色的时候

535
00:56:08.841 --> 00:56:18.999
她已经可以确定第一张卡牌对应的子序列, 因为她知道那张牌对应的5个bit

536
00:56:19.114 --> 00:56:24.340
然后她有些绝妙的办法判断剩下的卡牌是什么

537
00:56:24.340 --> 00:56:29.005
这就是deBruijn序列和你刚才看到的魔术的关系

538
00:56:33.734 --> 00:56:35.599
有问题吗?

539
00:56:35.852 --> 00:56:40.914
听众: 能循环deBruijn序列吗?

540
00:56:40.943 --> 00:56:43.110
JULIAN SHUN: 其实可能有多个deBruijn序列

541
00:56:43.110 --> 00:56:48.444
我们只需要一个就能让这个技巧奏效

542
00:56:51.986 --> 00:57:03.910
这个例子是k=3, 之前给你们看的是k=8, 所以对64位整数奏效

543
00:57:04.334 --> 00:57:07.525
听众: 为什么存在这么一个序列呢?

544
00:57:07.525 --> 00:57:10.426
JULIAN SHUN: 有一份数学证明存在性

545
00:57:10.919 --> 00:57:14.500
我可以给一些连接, 你课后自己查看

546
00:57:14.500 --> 00:57:19.536
但有一个证明说, 对于任何长度, 都存在对应的deBruijn序列

547
00:57:23.193 --> 00:57:27.870
听众: 对不起, 我没跟上, 你怎么确定log_2结果的?

548
00:57:31.650 --> 00:57:36.960
JULIAN SHUN: 从一个二次幂整数开始

549
00:57:36.983 --> 00:57:43.978
乘以这个数字的时候就是在左移, 左移位数就是以2为底它的对数

550
00:57:43.990 --> 00:57:53.820
因为我们可以通过前三bit, 确定我们左移了多少位

551
00:57:53.837 --> 00:58:03.727
所以只需要左移之后, 看看3bit出现在原来的deBruijn序列的哪里

552
00:58:04.163 --> 00:58:07.095
然后你只需要查表就能知道左移了多少位

553
00:58:07.531 --> 00:58:18.240
这是表中查找110的过程, 告诉我们从4开始, 所以是左移了四位

554
00:58:18.246 --> 00:58:24.520
因此以2为底n的对数就是4, 懂了吗?

555
00:58:26.059 --> 00:58:32.332
听众: 确认一下, 只有乘以二次幂, 才会返回幂的底数?

556
00:58:32.337 --> 00:58:38.760
JULIAN SHUN: 没错, 只有你乘以二次幂的时候, 否则不起效

557
00:58:46.125 --> 00:58:48.089
还有别的问题吗?

558
00:58:52.001 --> 00:58:57.505
如果不是二次幂, 你可以用之前的技巧变成最接近的二次幂

559
00:58:57.511 --> 00:58:59.420
然后你就能用这个技巧了

560
00:59:02.430 --> 00:59:08.511
这个技巧的性能限制于乘法和查表的速度

561
00:59:08.574 --> 00:59:16.944
你需要乘以一个常数, 然后查表转换结果

562
00:59:17.460 --> 00:59:21.979
查表需要访问内存, 有可能会很慢

563
00:59:21.990 --> 00:59:28.095
其实现在有一条硬件指令来做这个, 所以你不必手动实现这个技巧

564
00:59:28.680 --> 00:59:36.273
但它还是很有意思, 有硬件指令之前, 过去都是这么做的

565
00:59:41.028 --> 00:59:44.988
下一个问题, n皇后问题

566
00:59:45.005 --> 00:59:46.780
多少人以前见过这个问题?

567
00:59:47.240 --> 00:59:49.494
所以你们大部分人都见过

568
00:59:49.970 --> 00:59:52.204
提醒一下, 我要把n个皇后放到n x n大小的棋盘上

569
00:59:52.210 --> 00:59:56.822
而且皇后之间不能互相攻击

570
00:59:57.270 --> 01:00:02.508
换句话说, 皇后不能同行, 同列, 或者对角线

571
01:00:02.961 --> 01:00:10.525
一般, 给定n, 我们想知道n皇后问题有几种摆法

572
01:00:10.536 --> 01:00:17.270
图上所示是一种合理的摆法, 你可以检查每个皇后

573
01:00:17.270 --> 01:00:19.517
他们确实不能攻击棋盘上的其他皇后

574
01:00:23.014 --> 01:00:28.511
解决n皇后的常见方法是倒推法

575
01:00:29.090 --> 01:00:31.440
我们尝试一行一行的摆放皇后

576
01:00:31.440 --> 01:00:38.007
因为每行只能有一个皇后, 所以只要确定那一行里皇后应该摆在哪就行

577
01:00:38.007 --> 01:00:42.489
如果不能确定皇后摆在哪一行, 就倒推

578
01:00:43.000 --> 01:00:48.800
比如第一行, 我们把皇后放在第一个位置

579
01:00:48.800 --> 01:00:52.989
因为棋盘上还没有皇后, 所以可以放在第一点上

580
01:00:52.989 --> 01:00:57.516
第二行, 我们依然尝试放到第一行

581
01:00:58.348 --> 01:01:05.501
但不能放在那儿, 因为可以攻击第一个皇后, 第二点也不行

582
01:01:05.507 --> 01:01:10.500
所以我们在第三点放下第二个皇后

583
01:01:10.511 --> 01:01:18.721
第三行, 我们会一个位置一个试, 直到可行, 也就是第五点

584
01:01:21.005 --> 01:01:25.241
再做一遍, 但这次可以放在第二点

585
01:01:25.780 --> 01:01:29.840
第五行, 看看它会放在哪

586
01:01:30.340 --> 01:01:34.794
所以它放在第四点, 第六行....

587
01:01:44.215 --> 01:01:48.430
阿, 所有八个点都不可行

588
01:01:48.430 --> 01:01:53.622
不管放在哪个点, 都能攻击之前放过的皇后

589
01:01:53.639 --> 01:01:58.650
所以现在我们需要倒退, 给第五行的皇后找个新位置

590
01:01:58.673 --> 01:02:08.274
试些新位置, 比如放在最后, 再试一下第六行

591
01:02:16.831 --> 01:02:21.635
好吧, 还是找不到第六行的位置

592
01:02:21.635 --> 01:02:24.843
需要继续倒退, 因为已经试过第五行可能的三个位置

593
01:02:24.843 --> 01:02:28.874
所以需要倒退第四行, 这就是大概思路

594
01:02:28.897 --> 01:02:35.178
只要找到八个皇后都能放下的布局, 就给什么计数器加1

595
01:02:35.189 --> 01:02:40.720
最后返回这个计数器, 表明n皇后谜题有几种摆法

596
01:02:48.424 --> 01:02:55.450
你可以简单的用递归实现这个解决方法. 这个倒退搜索法

597
01:02:56.167 --> 01:03:02.869
不过, 怎么表示棋盘才能高效的解决皇后摆放问题?

598
01:03:02.875 --> 01:03:08.545
一种办法是使用一个n^2个字节的数组

599
01:03:08.551 --> 01:03:15.994
每个字节, 1表示有皇后, 否则是0

600
01:03:15.994 --> 01:03:19.240
有更好的办法吗?

601
01:03:27.032 --> 01:03:33.989
听众: 你可以用bit代表一个位置上有没有皇后?

602
01:03:34.344 --> 01:03:36.770
JULIAN SHUN: 没错, 回答的好

603
01:03:36.770 --> 01:03:41.470
所以不是用字节, 我们可以用bit, 因为bit要么0, 要么1

604
01:03:41.470 --> 01:03:47.004
只需要1bit我们就能表示了, 所以需要n^2个bit的数组

605
01:03:47.015 --> 01:03:50.074
有更好的办法吗?

606
01:03:57.525 --> 01:04:02.192
听众: 你可以用一字节表示一行?

607
01:04:02.192 --> 01:04:03.840
JULIAN SHUN: 是的, 回答正确

608
01:04:03.840 --> 01:04:07.380
所以更好的方式是用一个n字节的数组

609
01:04:07.380 --> 01:04:14.499
因为每一行只能有一个皇后, 所以只需要存储那个皇后的位置就行了

610
01:04:14.516 --> 01:04:17.232
这个字节数组总共有n字节, 一字节一行

611
01:04:17.232 --> 01:04:20.630
你用一个字节就可以存储那一行皇后的位置

612
01:04:23.706 --> 01:04:27.740
但是实际上, 有更紧凑的表示方法

613
01:04:27.740 --> 01:04:34.485
就是使用三个bit向量, 大小分别是n, 2n-1, 2n-1

614
01:04:34.915 --> 01:04:40.394
现在来看看他的原理, 第一个向量的长度是n

615
01:04:40.423 --> 01:04:43.450
我们把这个向量叫做down向量

616
01:04:43.450 --> 01:04:49.735
down向量会在有皇后的那一列设1, 没有皇后就放0

617
01:04:52.973 --> 01:05:02.210
如果我们要在某一列放皇后, 首先需要检查那一列是不是空的

618
01:05:02.210 --> 01:05:08.154
你可以1左移c位后, 和down向量相与来检查

619
01:05:08.154 --> 01:05:10.996
其中c是你想要放皇后的那一列

620
01:05:11.008 --> 01:05:15.975
如果非0, 就意味着那一列已经有一个皇后, 你不能在那列放

621
01:05:16.973 --> 01:05:23.686
否则你需要做另一检查, 这次要用的是叫做left的bit向量

622
01:05:23.709 --> 01:05:33.230
这个向量的长度是2n-1, 他在对角线上有皇后的位置设1, 否则放0

623
01:05:33.230 --> 01:05:41.505
一共有2n-2条可能的对角线, 如果我们想要在行r, 列c放皇后

624
01:05:41.510 --> 01:05:48.977
我们可以通过left & (1 << (r+c))检查

625
01:05:48.995 --> 01:05:56.905
如果那个地方已经有皇后, 结果就是非0, 我们就不能放皇后

626
01:05:56.910 --> 01:06:01.220
否则我们做最后一个检查, 使用right这个bit向量

627
01:06:01.220 --> 01:06:08.025
这和left向量是一样, 但是对角线是从左上到右下

628
01:06:08.593 --> 01:06:14.482
如果对角线上有皇后就放1, 没有就放0

629
01:06:14.494 --> 01:06:22.030
这次需要检查right & (1 << (n-1+r+c))

630
01:06:23.097 --> 01:06:32.993
如果所有三个测试都通过了, 我们就知道没有冲突, 那个位置可以放下这个皇后

631
01:06:34.020 --> 01:06:44.600
这就是bit向量表示, 但你还得计数放下的皇后, 这是个很有意思的练习

632
01:06:44.600 --> 01:06:52.284
所以我鼓励你们课后练习, 刚才说的是bit向量表示, 有问题吗?

633
01:06:56.010 --> 01:07:01.477
听众: 能重复一下down这个向量是怎么确定能否放皇后的吗?

634
01:07:01.482 --> 01:07:03.290
JULIAN SHUN: 可以

635
01:07:03.290 --> 01:07:08.509
down向量会在存在皇后的列上设1, 否则设0

636
01:07:08.555 --> 01:07:15.840
如果你想在列c上放皇后, 你首先把1左移c

637
01:07:15.840 --> 01:07:20.660
然后和down向量相与, 如果结果非0, 说明那一列有皇后

638
01:07:26.933 --> 01:07:28.926
还有别的问题吗?

639
01:07:29.430 --> 01:07:31.635
听众: 为什么没有检查行的向量呢?

640
01:07:31.916 --> 01:07:34.050
JULIAN SHUN: 答案是你不需要

641
01:07:34.050 --> 01:07:42.855
只需要三个检查就足够判断能否在特定位置放下皇后

642
01:07:42.885 --> 01:07:46.165
所以四次检查是多余的

643
01:07:46.635 --> 01:07:50.282
听众: 因为我们不在同一行放两个皇后, 所以不需要检查行?

644
01:07:50.305 --> 01:07:51.910
JULIAN SHUN: 确实是这样, 角度很好

645
01:07:52.364 --> 01:07:55.144
我们只在行里某一个位置放皇后

646
01:08:01.110 --> 01:08:07.995
下一个问题, 位计数(population count), 简称pop count

647
01:08:08.001 --> 01:08:14.003
问题是我们想计数字x中为1的bit数

648
01:08:14.840 --> 01:08:20.236
这是一个不断消除最低位的1的解法

649
01:08:20.455 --> 01:08:28.061
这个循环首先初始化r为0, 然后循环直到x变为0

650
01:08:28.560 --> 01:08:37.232
每次循环都给r加1, 每次循环都令x = x & (x-1)

651
01:08:37.267 --> 01:08:41.486
这会清楚x中最低位的1

652
01:08:41.491 --> 01:08:47.606
看个例子, x的值如图所示

653
01:08:47.623 --> 01:08:57.222
x-1会把最低位的1反转为0, 右侧的所有0反转为1

654
01:08:57.222 --> 01:09:06.551
对他俩与运算, 会把所有值都复制, 直到最低位的1

655
01:09:06.574 --> 01:09:10.260
这个1会被清零, 因为x-1那一位是0

656
01:09:10.260 --> 01:09:13.290
然后右侧所有的bit仍然还是0

657
01:09:13.290 --> 01:09:20.981
所以x & (x-1)会把最低位的1清零

658
01:09:21.687 --> 01:09:27.699
重复这个过程, 直到x变成0, 那时我们已经消去了所有的1

659
01:09:27.699 --> 01:09:35.735
然后1的数量就存放在r中, 问题?

660
01:09:41.500 --> 01:09:45.685
如果1的数量很少, 这份代码会跑得很快

661
01:09:45.685 --> 01:09:50.450
但它的运算时间和1的数量成正比

662
01:09:50.450 --> 01:10:00.142
最坏的情况下, 如果所有位都是1, 迭代很多次才能跑完

663
01:10:00.159 --> 01:10:06.995
还有一种更效率的方式解决问题, 就是查表

664
01:10:07.007 --> 01:10:17.684
创建一个256长度的表, 存放每个8bit字对应的1的数量

665
01:10:17.706 --> 01:10:27.400
所有8bit字都存在这个表中, 想要计算x的数量

666
01:10:27.400 --> 01:10:35.696
对字节查表, 然后累加到r中

667
01:10:35.730 --> 01:10:42.987
接着右移8位, 然后下一个字节, 循环往复, 直到x变为0

668
01:10:43.038 --> 01:10:45.390
这是查表计算

669
01:10:45.390 --> 01:10:55.562
性能决定于x的大小, 如果是64位字, 最多需要做八次

670
01:10:55.573 --> 01:11:01.993
而之前的方法, 如果有64个1, 就要迭代64次

671
01:11:02.750 --> 01:11:10.540
这种方法受限于内存, 因为表是存在内存里的

672
01:11:10.540 --> 01:11:15.537
所以每次操作都需要访问内存, 获取对应值

673
01:11:15.537 --> 01:11:22.600
这是访问各级内存大概需要的时间

674
01:11:22.600 --> 01:11:27.240
寄存器中非常快, 一个时钟周期即可

675
01:11:27.240 --> 01:11:34.184
L1需要大概4周期, L2需要大概10周期, L3需要大概50周期

676
01:11:34.196 --> 01:11:40.482
最后, 如果你需要到DRAM获取, 而不是cache, 会非常慢, 大概150周期

677
01:11:40.494 --> 01:11:47.348
比起访问寄存器, 这慢了整整一个量级

678
01:11:49.620 --> 01:11:57.660
现在看看第三种解法, 不需要cache, 也不需要DRAM

679
01:11:57.660 --> 01:12:03.193
其实一切都可以在寄存器内做, 你可以这么做

680
01:12:03.210 --> 01:12:10.499
我们要创建五个掩码, 或者说六个, 从M0到M5

681
01:12:10.504 --> 01:12:15.840
掩码的值写在注释中

682
01:12:15.840 --> 01:12:20.655
这个记号, x^k表示x重复k次

683
01:12:20.672 --> 01:12:25.988
M5有32个0, 跟着32个1

684
01:12:26.023 --> 01:12:32.265
M0掩码是01重复32次, 以此类推

685
01:12:34.493 --> 01:12:40.030
做出掩码后, 执行下面的六条指令

686
01:12:40.030 --> 01:12:44.787
这会算出字中1的数量

687
01:12:44.804 --> 01:12:48.903
来个例子看看它的原理把

688
01:12:48.932 --> 01:12:51.270
从这串初始值开始算

689
01:12:52.771 --> 01:12:59.602
首先我们先和掩码M0进行与运算

690
01:12:59.608 --> 01:13:04.398
然后和x右移一位后和M0进行与运算

691
01:13:04.432 --> 01:13:11.966
回想M0的掩码是01重复32次

692
01:13:11.983 --> 01:13:16.572
因此这个掩码取出了所有偶数位的bit

693
01:13:16.601 --> 01:13:21.180
x和M0相与得到所有偶数位bit

694
01:13:21.180 --> 01:13:25.985
然后把x右移1位, 再和M0相与, 就得到了所有奇数位bit

695
01:13:25.991 --> 01:13:30.734
把这个两个放一起, 加起来

696
01:13:30.751 --> 01:13:39.509
结果是每2bit一组, 每组中1的数量

697
01:13:39.526 --> 01:13:45.385
现在每组都会告诉我们有多少个1

698
01:13:45.396 --> 01:13:52.440
最左侧, 两个1相加得2

699
01:13:52.440 --> 01:13:57.621
最右侧, 两个0相加得00

700
01:13:57.638 --> 01:14:09.011
所有组都是这样的, 结果是每组中1的数量

701
01:14:09.028 --> 01:14:14.757
现在把结果和M1相与

702
01:14:14.769 --> 01:14:21.215
然后右移两位, 再和M1相与, 再把两个结果加起来

703
01:14:22.931 --> 01:14:33.120
M1会分成每组4bits, 右移时候拿到高两位

704
01:14:33.120 --> 01:14:40.830
把这些加起来就是每组4个bit中1的数量

705
01:14:40.858 --> 01:14:50.250
数量都存在结果中, 你可以验证一下是不是正好是1的数量

706
01:14:50.250 --> 01:14:57.819
比如这组是100, 这是对的, 因为这4bits都是1

707
01:14:59.232 --> 01:15:08.698
再用M2重复相同的流程, 就得到大小为8的组

708
01:15:08.733 --> 01:15:20.937
然后大小为16的组, 最后把大小为32的组加起来得到64大小

709
01:15:20.994 --> 01:15:25.708
结果就是pop count, 所以有17个1

710
01:15:25.714 --> 01:15:35.660
你可以验证一下输入确实有17个1. 有问题吗?

711
01:15:41.201 --> 01:15:46.140
这串代码的性能基于并行的分治法

712
01:15:46.191 --> 01:15:51.476
和w以2为底的对数成正比, w是字长

713
01:15:51.481 --> 01:16:00.766
因为每次我都在翻倍问题大小, 执行lgw次后, 就是整组的结果

714
01:16:04.680 --> 01:16:14.200
前两条指令中, 我分开做与运算

715
01:16:14.200 --> 01:16:20.630
分开x>>1和x, x>>2和x, 然后才加起来

716
01:16:20.630 --> 01:16:33.940
因为合起来可能会溢出, 因为每组的大小可能放小于那组中1的数量

717
01:16:33.940 --> 01:16:41.477
不过组大起来后, 数量就能安全的放进那一组里了, 就不需要担心溢出了

718
01:16:41.523 --> 01:16:48.390
所以后四条指令每条都可以省下一条指令, 不需要与运算两次

719
01:16:55.863 --> 01:17:02.345
但是大部分现代机器, 其实都有个用硬件实现的pop count指令

720
01:17:02.362 --> 01:17:05.427
不管你写什么, 这个指令都要更快

721
01:17:05.444 --> 01:17:12.838
你可以借由编译器的库使用这个指令, 比如gcc和clang

722
01:17:13.515 --> 01:17:18.146
gcc中是__builtin_popcount

723
01:17:20.860 --> 01:17:31.190
不过如果你用了这些指令, 却尝试在不支持指令的机器上编译, 就会编译失败

724
01:17:31.190 --> 01:17:38.689
所以你代码的可移植性会下降, 但这个固有指令比并行分治法要快

725
01:17:40.761 --> 01:17:46.190
这就引出一个问题, 你要怎么获取二次幂的底数, 使用pop count指令?

726
01:17:46.190 --> 01:17:49.025
而不是使用deBruijn序列的技巧

727
01:17:52.401 --> 01:17:54.772
听众: 自减然后pop count

728
01:17:54.772 --> 01:17:59.353
JULIAN SHUN: 没错, 首先从二次幂减1

729
01:17:59.668 --> 01:18:04.810
这会让二次幂所有的低位上的0都变成1, 然后执行pop count

730
01:18:04.810 --> 01:18:09.460
就会计数有多少个1, 正好是二次幂的底数

731
01:18:09.460 --> 01:18:17.130
答得好, 我今天就讲这么多位运算技巧

732
01:18:17.130 --> 01:18:21.150
如果你感兴趣的话, 网上还有更多资源

733
01:18:21.150 --> 01:18:26.278
Sean Eron Anderson维护着一个相关的优秀网站

734
01:18:26.760 --> 01:18:30.348
Knuth的教科书也有谈到位运算技巧

735
01:18:30.388 --> 01:18:34.650
还有chess programming网站, 也有很多炫酷的位运算技巧

736
01:18:34.650 --> 01:18:37.200
有一些是用在象棋问题编程中的

737
01:18:37.200 --> 01:18:39.568
以及最后的最后Hacker's Delight这本书

738
01:18:39.568 --> 01:18:45.710
项目1中会遇到很多位运算技巧, 祝你位运算魔术表演快乐!

739
01:18:45.724 --> 01:18:54.530
翻译&校对&时轴: xhe
Github: xhebox/mit6172_cn
